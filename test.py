# Версия 6.0 работает!# from kivy.config import Config# Config.set('kivy', 'keyboard_mode', 'systemanddock')from kivy.clock import Clockfrom kivy.app import Appfrom kivy.uix.boxlayout import BoxLayoutfrom kivy.uix.floatlayout import FloatLayoutfrom kivy.uix.anchorlayout import AnchorLayoutfrom kivy.uix.gridlayout import GridLayoutfrom kivy.uix.scrollview import ScrollViewfrom kivy.uix.label import Labelfrom kivy.uix.button import Buttonfrom kivy.uix.textinput import TextInputfrom kivy.uix.widget import Widgetfrom kivy.core.window import Windowfrom kivy.properties import StringProperty, BooleanProperty, ObjectProperty, ListProperty# (NumericProperty, ReferenceListProperty, ObjectProperty)import os.pathclass MainWidget(FloatLayout):  passclass FileMenuW(BoxLayout):  passclass TestApp(App):  # объявляем переменные  is_file_list = BooleanProperty(False)  is_text_area = BooleanProperty(False)  is_button_edit = BooleanProperty(False)  is_folder_list = BooleanProperty(False)  is_create_file = BooleanProperty(False)  # is_file_list [0], is_folder_list [1], is_text_area, is_button_edit, is_create_file  state = ListProperty([False, False, False, False, False])  last_state = ListProperty([False, False, False, False, False])  # [0] is_button_file_list_pressed "=",   # [1] is_button_plus_pressed "+", ok  # [2] is_button_edit_pressed "/",   # [3] is_choice_file_pressed "file.txt", ok  # [4] is_choice_folder_pressed "folder"  state_buttons = ListProperty([ False, False, False, False, False])  file_name = StringProperty('note.txt')  subdir = ListProperty()  dir_tek = StringProperty()  button_file_list = ObjectProperty()  button_edit = ObjectProperty()  # Функция для определения состояния приложения - переменные или переменная состояния  # вызываем из каждой функции вставляя имя той функции откуда вызываем  def state_app(self, func_name, *args, **kwargs):    #      state_at_begining = {    #        'file_list': self.is_file_list,    #        'folder_list': self.is_folder_list,    #        'text_area': self.is_text_area,    #        'button_edit': self.is_button_edit,    #        'create_file': self.is_create_file  }    self.state = [      self.is_file_list,      self.is_folder_list,      self.is_text_area,      self.is_button_edit,      self.is_create_file    ]    # print(func_name.__name__, "used.")    print("NOW state:", self.state)    print("LAST state:", self.last_state)        # экран file_list    if self.state == [True, False, False, False, False]:      print("***file_list on screen***")      self.text_area.focus = False    # экран folder_list    elif self.state == [False, True, False, False, False]:      print("***folder_list on screen***")      self.text_area.focus = False    # экран text_area вместе с button_edit    if self.state == [False, False, True, True, False]:      print("***text_area with button_edit on screen***")      # print(self.button_edit in self.alt)    # экран text_area без button_edit    if self.state == [False, False, True, False, False]:      print("***text_area without button_edit on screen***")    # экран create_file:    elif self.state == [False, False, True, False, True]:      print("***create_file on screen***")  # Функция сохранения прошлого состояния  def last_state_change(self):    self.last_state = self.state    return  # Функция установки нового состояния  def config_new_state(self):        # Состояние для folder_list из file_list    if (self.last_state == [            True, False, False, False, False ] and          self.state_buttons == [           True, False, False, False, False ] ):      self.is_file_list = False #0      self.is_folder_list = True #1      self.state_app(self.config_new_state)      # теперь self.state =       # [ False, True, False, False, False]        # Состояние для file_list из folder_list    if self.last_state == [      False, True, False, False, False ]:      self.is_file_list = True #0      self.is_folder_list = False #1      self.state_app(self.config_new_state)            # Состояние для file_list из text_area    if (self.last_state == [           False, False, True, True, False ] or         self.last_state == [           False, False, True, False, False ]):      self.is_file_list = True #0      self.is_text_area = False #2      self.is_button_edit = False #3      self.state_app(self.config_new_state)      # теперь self.state =       # [ True, False, False, False, False]        # Состояние для file_list из create_file    if self.last_state == [      False, False, True, False, True ]:      self.is_file_list = True #0      self.is_text_area = False #2      self.is_create_file = False #4      self.state_app(self.config_new_state)            # Функция отключения виджетов прошлого состояния  def off_widgets_last_state(self):    # Отключение file_list (перед create_file)    if self.last_state == [      True, False, False, False, False]:      self.off_file_list()      #self.off_folder_list()      self.is_file_list = False      #self.is_folder_list = False      self.state_app(self.off_widgets_last_state)        # Отключение folder_list (перед file_list)    if self.last_state == [      False, True, False, False, False ]:      self.off_folder_list()      self.is_folder_list = False      self.state_app(self.off_widgets_last_state)    # Отключение create_file (перед file_list)    if self.last_state == [      False, False, True, False, True]:      self.create_file_off()      self.is_text_area = False      self.is_create_file = False      self.state_app(self.off_widgets_last_state)    # Отключение text_area и button_edit    if self.last_state == [      False, False, True, True, False]:      print("off text_area and button_edit")      self.off_text_area()      self.is_text_area = False      self.is_button_edit = False      self.state_app(self.off_widgets_last_state)    # Отключение text_area без button_edit    if self.last_state == [      False, False, True, False, False ]:      print("off text_area without button_edit")      self.off_text_area()      self.is_text_area = False      #self.is_button_edit = False      self.state_app(self.off_widgets_last_state)  ## Функция включения виджетов в текущий экран  def on_widgets_new_state(self):    self.begin_func(self.on_widgets_new_state)        print(self.state)    # Включение file_list, начальный экран    if self.state == [      True, False, False, False, False ]:      self.file_list_building()    # Включение folder_list    if self.state == [      False, True, False, False, False ]:      print("folder_list building")      self.on_folder_list()      self.is_folder_list = True      self.alt.remove_widget(self.button_edit)      self.alt.remove_widget(self.button_plus)      self.state_app(self.on_file_list)    # Включение create_file    if self.state == [        False, False, True, False, True]:      self.create_file_building()# Файловая функция# прочесть текущий файл в объект text_area.# вызываем из choice_file()  def open_in_area(self, file_name):    self.begin_func(self.open_in_area)    self.last_state_change()    # настройка переменных для вывода    if os.path.isfile(self.file_name):      with open(self.file_name, 'r') as file:        self.text_area.text = file.read()    # Вывод на экран text_area и button_edit    #self.scroll_text_area.add_widget(self.text_area)    #self.layout.add_widget(self.scroll_text_area)    self.layout.add_widget(self.text_area, index = 2)    self.alt.add_widget(self.button_edit, index = 0)    # Объявляем новое состояние    self.is_file_list = False    self.is_button_edit = True    self.is_text_area = True    self.button_folder_list()    # состояние приложения    self.state_app(self.open_in_area)    return# Отключение text_area с экрана.  def off_text_area(self):    self.save_file()    self.layout.remove_widget(self.text_area)    self.alt.remove_widget(self.button_edit)# Файловая функция# сохраняем из text_area в текущий файл# вызывается из on_file_list и on_stop при условии, что self.is_text_area = True  def save_file(self):    self.begin_func(self.save_file)    self.last_state_change()    index_of_cr = self.text_area.text.find("\n")    if index_of_cr == -1:      self.file_name = self.text_area.text + ".txt"    else:      self.file_name = self.text_area.text[0:index_of_cr] + ".txt"    if self.file_name == ".txt":      self.label_filename.text = "          Не сохранил"      return    print("имя файла:", self.file_name)    with open(self.file_name, 'w') as file:      file.write(self.text_area.text)    self.label_filename.text = f'                    Сохранил в {self.file_name}'    #print(" 'save file' used")    self.state_app(self.save_file)    self.end_func(self.save_file)    return# Файловая функция# вызывается кнопкой "+"  def create_file(self, button_plus):    self.begin_func(self.create_file)    print("Button '+' pressed.")    # сохраняем текущее состояние в прошлое    self.last_state_change()    # изменяем текущее состояние    self.is_create_file = True    self.is_text_area = True    ## отключаем виджеты прошлого состояния    self.off_widgets_last_state()    # изменяем снова текущее состояние    self.is_create_file = True    self.is_text_area = True    self.state_app(self.create_file)    #button "+" pressed    self.state_buttons[1] = True    print("button '+' pressed.", self.state_buttons)    ## выводим новое состояние на экран    # выводим text_area и редактируем    self.on_widgets_new_state()    self.state_app(self.create_file)    self.end_func(self.create_file)    return# Включение виджетов create_file  def create_file_building(self):    self.begin_func(self.create_file_building)    self.label_filename.text = "new"    self.text_area.text = ""    self.layout.add_widget(self.text_area)    self.is_text_area = True    self.button_folder_list()    self.text_area.focus = True    self.end_func(self.create_file_building)    return  # Отключение create_file с экрана  def create_file_off(self):    self.begin_func(self.create_file_off)    #if self.last_state[2]:    self.save_file()    self.layout.remove_widget(self.text_area)    self.alt.remove_widget(self.button_edit)    self.end_func(self.create_file_off)    return  def rewrite_widget(self, widget_name):      self.layout.remove_widget(widget_name)      self.layout.add_widget(widget_name)# вызывается по нажатию кнопки "<-" или "="  def button_folder_list(self):    self.begin_func(self.button_folder_list)    #self.last_state_change()    if (not self.is_text_area and        not self.is_file_list and               self.is_folder_list):      self.button_file_list.text = "="      self.rewrite_widget(self.button_file_list)      self.state_app(self.button_folder_list)    if (not self.is_text_area and self.is_file_list and        not self.is_folder_list):      self.button_file_list.text = "="    if self.is_text_area:      self.button_file_list.text = "<-"      self.rewrite_widget(self.button_file_list)      self.state_app(self.button_folder_list)    self.end_func(self.button_folder_list)    return# Файловая функция# НАЧАЛЬНЫЙ ЭКРАН.# вызывается кнопкой "<-".  def on_file_list(self, *args):    self.begin_func(self.on_file_list)    print("Button '<-', '=' pressed or On_file_list used")    # Сохраняем прошлое состояние    self.last_state_change()    ## Объявляем новое состояние для file_list    #self.config_new_state()    #self.is_file_list = True #0    #self.is_text_area = False #2    #self.is_create_file = False #4    # Обновляем self.state    #self.state_app(self.on_file_list)    self.state_buttons = [ True, False, False, False, False ]    self.config_new_state()    # отключаем виджеты прошлого состояния    self.off_widgets_last_state()    # Выводим file_list    self.on_widgets_new_state()        self.end_func(self.on_file_list)    return    # Включение file_list  def file_list_building(self):      self.begin_func(self.file_list_building)            #self.last_state_change()      self.func_file_list()      self.button_list_menu = []      for i in range(len(self.files_txt)):        self.button_list_menu.append(i)        self.button_list_menu[i] = Button(          text = self.files_txt[i],          on_release = self.choice_file )        self.grd.add_widget(self.button_list_menu[i])      self.is_file_list = True      # замена кнопки "<-" на "="      self.button_folder_list()      #self.rewrite_widget(self.button_plus) # сюда не подойдет, потому что alt, а не layout      self.alt.remove_widget(self.button_plus)      self.alt.add_widget(self.button_plus)      # func, delay      self.shed_func(self.on_label_filename_text, 1)      self.end_func(self.file_list_building)      return# Выключение file_list с экрана  def off_file_list(self):    self.begin_func(self.off_file_list)    #self.last_state_change()    for i in range(len(self.files_txt)):      self.grd.remove_widget(self.button_list_menu[i])    self.alt.remove_widget(self.button_plus)    self.state_app(self.off_file_list)    self.end_func(self.off_file_list)    return# вызываем из on_file_list через shed_func  def on_label_filename_text(self, instance):    #self.begin_func(self.on_label_filename_text)    if self.is_text_area == False:      self.dir_tek = os. getcwd()      #print(self.dir_tek)      if len(self.dir_tek) > 10:        self.dir_tek = self.dir_tek[ len(self.dir_tek) - 20 : len(self.dir_tek)]      self.label_filename.text = "        ..." + self.dir_tek      #" Папка такая-то "def on_folder_list(self):# Включение folder_list на экран  def on_folder_list(self):    self.begin_func(self.on_folder_list)    self.last_state_change()    self.subdir = self.func_folder_list()    self.button_folder_list_menu = []    #print("self subdir =", self.subdir, "длина:", len(self.subdir))    for i in range(len(self.subdir)):      self.button_folder_list_menu.append(i)      self.button_folder_list_menu[i] = Button(        text = self.subdir[i],        #size_hint_y = None,        on_release = self.choice_folder )      self.grd.add_widget(self.button_folder_list_menu[i])    self.is_folder_list = True    self.shed_func(self.on_label_filename_text, 1)    #self.label_filename.text = self.dir_tek    self.state_app(self.on_folder_list)    self.end_func(self.on_folder_list)    return# Отключение folder_list с экрана  def off_folder_list(self):      self.begin_func(self.off_folder_list)      #self.last_state_change()      for i in range(len(self.subdir)):        self.grd.remove_widget(self.button_folder_list_menu[i])      self.is_folder_list = False      self.state_app(self.off_folder_list)      self.end_func(self.off_folder_list)      return  def func_folder_list(self):    #self.begin_func(self.func_folder_list)    all_list = os.listdir()    self.folder_list = []    self.dir_tek = os. getcwd()    example_dir = self.dir_tek    #'/storage/emulated/0/Documents/Pydroid3'    with os.scandir(example_dir) as files:      subdir = [file.name for file in files if file.is_dir()]      subdir.insert(0, "..")      #print(subdir)    self.state_app(self.func_folder_list)    return subdir# Файловая функция# читаем файлы в список self.files_txt# вызываем из on_file_list  def func_file_list(self):    #self.begin_func(self.func_file_list)    file_list = os.listdir()    self.files_txt = []    for i in file_list:      if ".txt" in i:        self.files_txt.append(i)    self.state_app(self.func_file_list)    return# Файловая функция# выбрали файлик и открываем его в объекте self.text_area# вызываем из on_file_list  def choice_file(self, file_list_building):    self.begin_func(self.choice_file)    print("File choice pressed.")    # Сохраняем прошлое состояние    self.last_state_change()    # Определяем новое состояние    #     # Берем нужные переменные из прошлого состояния    self.file_name = file_list_building.text    self.label_filename.text = self.file_name    # Удаляем виджеты прошлого состояния    self.off_file_list()    # Если нужно повторяем новое состояние    self.state_buttons[3] = True    print("button file_choice pressed.", self.state_buttons)    # Добавляем виджеты нового состояния    self.open_in_area(self.file_name)    self.focus_text_area()    self.state_app(self.choice_file)        self.end_func(self.choice_file)    return# Как choice_file, только для folder  def choice_folder(self, on_folder_list):    self.begin_func(self.choice_folder)    self.last_state_change()    #print(on_folder_list.text)    os.chdir(on_folder_list.text)    self.dir_tek = os. getcwd()    for i in range(len(self.subdir)):      self.grd.remove_widget(self.button_folder_list_menu[i])    self.is_folder_list = False    #self.off_folder_list()    self.subdir = self.func_folder_list()    #self.func_folder_list()    self.on_folder_list()    #self.on_label_filename_text()    #self.off_file_list()    self.state_app(self.choice_folder)    self.end_func(self.choice_folder)    return# ========================°# text_area функции.# вызываем из choice_file  def focus_text_area(self):    self.begin_func(self.focus_text_area)        if self.is_text_area == True:      self.text_area.bind( focus= self.on_focus_text_area)    else:      self.text_area.unbind( focus= self.on_focus_text_area)    self.state_app(self.focus_text_area)        self.end_func(self.focus_text_area)    return# вызываем из focus_text_area  def on_focus_text_area(self, *args):      self.begin_func(self.on_focus_text_area)      if self.is_button_edit == True:        self.text_area.focus = False        #self.text_area._keyboard = None      elif self.is_text_area == True and self.is_button_edit == False:        #self.text_area._keyboard = None        #self.text_area._keyboard = Window.request_keyboard(self._keyboard_closed, self, 'text')        self.text_area.focus = True        #self.text_area._keyboard = None        #Window      #print("Focus:", self.text_area.focus)      self.state_app(self.on_focus_text_area)      self.end_func(self.on_focus_text_area)      return  def _keyboard_closed(self):    print('My keyboard have been closed!')    #self._keyboard.unbind(on_key_down=self._on_keyboard_down)    self._keyboard = None# установка задержки delay для запуска функции func (указываем при вызове и delay тоже)# вызывается пока из on_file_list для вывода "папка такая-то"  def shed_func(self, func, delay, *args, **kwargs):    #self.begin_func(self.shed_func)    Clock.schedule_once(func, delay)    #print("function scheduled:", func.__name__)    self.state_app(self.shed_func)    return# text_area функция# вызываем кнопкой "/"  def shed_enter(self, button_edit):    #self.begin_func(self.shed_enter)    Clock.schedule_once(self.enter_text_area, 0.25)    self.state_app(self.shed_enter)    return# text_area функция# вызываем кнопкой "/". сейчас пока из shed_enter  def enter_text_area(self, button_edit):    self.begin_func(self.enter_text_area)        self.last_state_change()    print("Button '/' pressed")    self.alt.remove_widget(self.button_edit)    self.is_button_edit = False    self.alt.remove_widget(self.button_plus)    self.text_area.cursor = (0, 0)    self.rewrite_widget(self.text_area)    #self.scroll_text_area.add_widget(self.text_area)    self.text_area.focus = True    self.state_app(self.enter_text_area)    self.end_func(self.enter_text_area)    return#================================# рисуем.# определяем объекты для размещения в layout# вызываем из init  def config_widgets(self, *args, **kwargs):    self.begin_func(self.config_widgets)    self.text_area = TextInput(      padding = 50,      pos_hint = { 'left_x':0.1, 'y':0.11 },      size_hint = (1, 0.78),      background_color = (255, 255, 255, 0.1),      foreground_color = (1,1,1,0.9),      cursor = (0, 0),      #readonly = True,      focus = False,  )      #do_cursor_movement(control+cursor_home, control=False, alt=False) )      #scroll_from_swipe = True,  )      #scroll_distance = 21,      #scroll_timeout = 251  )    self.text_area.bind(minimum_height = self.text_area.setter('height'))        self.button_plus = Button(      text = '+',      size_hint = (.15, .09),      on_release = self.create_file      #on_state = print(" нажал '+' ")      #background_color = (255, 255, 255, 0.5)        )    #self.button_plus.bind(state=print("pressed +"))    #self.button_edit = ObjectProperty()        self.button_edit = Button(      text = '/',      size_hint = (.15, .09)      #on_release = self.enter_text_area      #background_color = (255, 255, 255, 0.5)        )    self.button_edit.bind(on_release=self.enter_text_area)    self.button_file_list = Button(      text = '<-',      size_hint = (.15, .09),      pos_hint = {"x":0, "y":0.90},      on_release = self.on_file_list)    self.label_filename = Label(      text = self.file_name,      halign = 'center',      size_hint = (.65, .10),      pos_hint = {'left_x': 0.6, 'center_y': 0.95} )    self.state_app(self.config_widgets)    self.end_func(self.config_widgets)    return# определяем объекты self.layout, self.grd, self.alt - лэйауты# вызываем из init  def config_layouts(self):    self.begin_func(self.config_layouts)    self.layout = FloatLayout()    #self.blt = BoxLayout(#      orientation = 'vertical',#      padding = [10, 220, 0, 50] )    self.scroll = ScrollView()    self.scroll_text_area = ScrollView()    self.grd = GridLayout(      size_hint_y = None,      #rows = 8,      cols = 1,      #height =      #height = '40sp' ,      padding = [0, 220, 0, 50],      spacing = 1,      row_force_default=True,      row_default_height='60sp'  )    self.grd.bind(minimum_height = self.grd.setter('height'))    self.alt = AnchorLayout(      anchor_x='right', anchor_y='bottom',      padding = [0, 0, 150, 30]      #bottom      )    self.state_app(self.config_layouts)    self.end_func(self.config_layouts)# при выходе из приложения сохраняет text_area в текущий файл и очищает виджеты  def on_stop(self):    self.begin_func(self.on_stop)        if self.is_text_area == True:      self.save_file()      print("saved")    self.layout.clear_widgets()    self.state_app(self.on_stop)    self.end_func(self.on_stop)    return# размещаем объекты на layout, в том числе добавляем self.grd на основной layout# вызываем из init  def add_widgets(self):    self.begin_func(self.add_widgets)    #self.scroll_text_area.add_widget(self.text_area)    self.scroll.add_widget(self.grd)    self.layout.add_widget(self.scroll)    #self.layout.add_widget(self.scroll_text_area)    self.layout.add_widget(self.button_file_list)    self.layout.add_widget(self.label_filename)    self.layout.add_widget(self.alt)    self.state_app(self.add_widgets)    self.end_func(self.add_widgets)    return#    for child in self.layout.children:#        if isinstance(child, Button):#            print("button true")        #print(child.__name__)    #print(str(self.layout.children))    #self.layout.add_widget(FileMenuW())# Выводим в консоль начало исполнения функции  def begin_func(self, func_name):    print("")    print(func_name.__name__, "begining!")# Выводим в консоль конец исполнения функции  def end_func(self, func_name):    print(func_name.__name__, "ending!")    print("")# собссно включение методов в приложение  def __init__(self, *args, **kwargs):    super(TestApp, self).__init__(*args, **kwargs)    self.begin_func(self.__init__)    self.title = 'Test'    #print("Начало исполнения")    # это вызываем только под классом TestApp. Здесь не работает    #is_file_list = BooleanProperty(False)    #is_text_area = BooleanProperty(False)    #TestApp.open_in_area(self, self.file_name)    # можно и как в строке выше    self.config_layouts()    self.config_widgets()    self.add_widgets()    self.last_state = [      False, False, False, False, False ]    self.is_file_list = True    self.state_app(self.__init__)    self.on_widgets_new_state()    self.state_app(self.__init__)    self.end_func(self.__init__)# строим главный layout на экране  def build(self):    #self.begin_func(self.build)    #self.state_app(self.build)    #self.end_func(self.build)    return self.layout    #MainWidget()# запускаем приложениеif __name__ == "__main__":  app = TestApp()  app.run()